# 1. capitalize()
# Возвращает копию строки, в которой первая буква переведена в верхний регистр (заглавная),
# а остальные — в нижний (строчные).
# Совет: если хотите сделать заглавными первые буквы всех слов в строке, используйте title().
# a = "bee sting"
# print(a.capitalize())

# 2.casefold()	Возвращает копию строки, в которой все буквы переведены в нижний регистр.
# Это может быть полезно для поиска соответствий без учета регистра.
# a = "BEE"
# print(a.casefold())

# 3. center(width[, fillchar])
# Этот метод помещает указанную строку в центр другой строки, ширина которой (в символах) определяется параметром width.
# Все пространство, не заполненное центральной строкой, заполняется символами, заданными в параметре fillchar
# (по умолчанию используется пробел ASCII).
# Если указанная ширина строки меньше, чем ширина исходной строки (len(s)), или равна ей, возвращается исходная строка.
# a = "bee"
# b = a.center(12, "-")
# print(b)

# 4. count(sub[, start[, end]])
# Метод возвращает число вхождений указанной подстроки sub в строку в заданном промежутке ([start, end]).
# Аргументы для определения начала и конца промежутка опциональны и интерпретируются как обозначение среза.
# При подсчете учитываются непересекающиеся вхождения. Это означает, что Python не будет заново прибавлять
# символы, которые уже были посчитаны.
# Например, если у вас есть строка хххх и вы хотите подсчитать, сколько в ней вхождений подстроки ххх, то в
# результате получите 1.
# a = "Mushroooom soup"
# print(a.count("O"))
# print(a.count("o"))
# print(a.count("oo"))
# print(a.count("ooo"))
# print(a.count("Homer"))
# print(a.count("o", 4, 7))
# print(a.count("o", 7))

# 5.encode(encoding="utf-8", errors="strict")
# Возвращает декодированную версию строки в качестве байтового объекта. Кодировка по умолчанию — utf-8.
# При помощи параметра errors можно задавать разные наборы схем обработки ошибок. Возможны следующие варианты:
# strict (ошибки декодирования вызывают UnicodeError)
# ignore
# replace
# xmlcharrefreplace
# backslashreplace
# любое другое слово, зарегистрированное через codecs.register_error()

# from base64 import b64encode
# a = "Banana"
# print(a)
# a = b64encode(a.encode())
# print(a)

# 6. endswith(suffix[, start[, end]])
# Возвращает True, если строка заканчивается на указанный суффикс; в противном случае возвращает False.
# Суффикс также может быть кортежем суффиксов.
# Если указывается аргумент start, проверка начинается с указанной позиции.
# При указании аргумента end проверка останавливается на указанном символе. Оба аргумента опциональны.
# a = "Banana"
# print(a.endswith("a"))
# print(a.endswith("nana"))
# print(a.endswith("z"))
# print(a.endswith("an", 1, 3))

# 7.expandtabs(tabsize=8)	Этот метод возвращает строку, в которой все символы
# табуляции (\t) заменяются одним или несколькими пробелами. При этом строка
# получается разделенной на столбцы. При помощи tabsize можно задать ширину столбцов в символах.
# a = "1\t2\t3"
# print(a)
# print(a.expandtabs())
# print(a.expandtabs(tabsize=12))
# print(a.expandtabs(tabsize=2))

# 8.find(sub[, start[, end]])
# Возвращает первый индекс в строке, на котором была найдена указанная подстрока.
# Можно указать диапазон поиска при помощи опциональных аргументов start и end (они интерпретируются как срез).
# Если подстрока в строке не найдена, возвращается -1.
# Примечание: метод find() стоит использовать, только если вам нужно знать позицию, с которой
# начинается подстрока. Если позиция вам не нужна и вы хотите просто проверить,
# встречается ли в строке эта подстрока, используйте оператор in.
# a = "Fitness"
# print(a.find("F"))
# print(a.find("f"))
# print(a.find("n"))
# print(a.find("ness"))
# print(a.find("ess"))
# print(a.find("z"))
# print(a.find("Homer"))

# 9.format(*args, **kwargs)
# При помощи этого метода можно отформатировать строку.
# Строка, относительно которой вызывается этот метод, может
# содержать простой текст или места для подстановки, обозначенные фигурными скобками.
# Каждое место для подстановки содержит или числовой индекс позиционного аргумента, или имя именованного аргумента.
# Метод возвращает строку, в которой каждое поле подстановки заменено строковым значением соответствующего аргумента.
# # Пример 1
# print("{} and {}".format("Tea", "Coffee"))
# # Пример 2
# print("{1} and {0}".format("Tea", "Coffee"))
# # Пример 3
# print("{lunch} and {dinner}".format(lunch="Peas", dinner="Beans"))
# # Пример 4
# print("{0}, {1}, {2}".format(*"123"))
# # Пример 5
# lunch = {"food": "Pizza", "drink": "Wine"}
# print("Lunch: {food}, {drink}".format(**lunch))

# 10.format_map(mapping)	Работа этого метода аналогична работе format(**mapping),
# за исключением того, что здесь отображение используется напрямую, без копирования в словарь.
# # Пример 1
# lunch = {"Food": "Pizza", "Drink": "Wine"}
# print("Lunch: {Food}, {Drink}".format_map(lunch))
# # Пример 2
# class Default(dict):
#     def __missing__(self, key):
#       return key
# lunch = {"Food": "Pizza"}
# print("Lunch: {Food}, {Drink}".format_map(Default(lunch)))
# lunch = {"Drink": "Wine"}
# print("Lunch: {Food}, {Drink}".format_map(Default(lunch)))

# 11.index(sub[, start[, end]])	Этот метод напоминает find(),
# который мы уже разбирали выше. Но здесь, если заданная подстрока
# не найдена в строке, вы получаете ValueError (в отличие от find(), который возвращает -1).
# a = "Fitness"
# print(a.index("F"))
# print(a.index("n"))
# print(a.index("ness"))
# print(a.index("ess"))
# print(a.index("z"))

# 12.isalnum()
# Этот метод возвращает True, если в строке есть хотя бы один символ,
# а все символы являются цифрами или буквами. В противном случае возвращается False.
# Значение переменной c считается буквенно-цифровым, если хотя бы одно из выражений возвращает True:
# c.isalpha()
# c.isdecimal()
# c.isdigit()
# c.isnumeric()
# c = "Fitness"
# print(c.isalnum())
# c = "123"
# print(c.isalnum())
# c = "1.23"
# print(c.isalnum())
# c = "$*%!!!"
# print(c.isalnum())
# c = "0.34j"
# print(c.isalnum())

# 13.isalpha()
# Возвращает True, если все символы в строке — буквенные (и при этом в строке есть хоть один символ).
# В противном случае возвращает False.
# Примечание. Имейте в виду, что под «буквенными» символами понимаются символы, определенные
# в базе данных Unicode как «буква», т. е., относящиеся к любой из категорий «Lm», «Lt», «Lu», «Ll» и «Lo».
# c = "Fitness"
# print(c.isalpha())
# c = "123"
# print(c.isalpha())
# c = "$*%!!!"
# print(c.isalpha())

# 14. isdecimal()
# Возвращает True, если все символы в строке являются десятичными символами (и если в строке есть хотя бы один символ).
# В противном случае возвращает False.
# К десятичным символам относятся символы, с помощью которых можно формировать числа в десятичной системе счисления.
# В Unicode эти символы относятся к общей категории «Nd».
# c = "123"
# print(c.isdecimal())
# c = u"\u00B2"
# print(c.isdecimal())
# c = "1.23"
# print(c.isdecimal())
# c = "u123"
# print(c.isdecimal())
# c = "Fitness"
# print(c.isdecimal())
# c = "$*%!!!"
# print(c.isdecimal())

# 15.isdigit()
# Возвращает True, если все символы в строке являются цифрами (и если в строке есть хотя бы один символ).
# Иначе возвращает False.
# Метод isdigit() часто используется, например, при работе с надстрочными символами
# Unicode (обозначающими степень числа).
# Цифра это символ, имеющий значение свойства Numeric_Type=Digit или Numeric_Type=Decimal.
# Разницу между методами isdigit() и isdecimal() можно увидеть, если посмотреть,
# как они работают со вторым примером (u»\u00B2″).
# c = "123"
# print(c.isdigit())
# c = u"\u00B2"
# print(c.isdigit())
# c = "1.23"
# print(c.isdigit())
# c = "u123"
# print(c.isdigit())
# c = "Fitness"
# print(c.isdigit())
# c = "$*%!!!"
# print(c.isdigit())

# 16.isidentifier()
# Возвращает True, если строка является допустимым идентификатором, определенным в
# разделе «Идентификаторы и ключевые слова» документации Python.
# Совет: для проверки зарезервированных идентификаторов, таких как def, for и class, используйте keyword.iskeyword().
# a = "123"
# print(a.isidentifier())
# a = "_user_123"
# print(a.isidentifier())
# a = "_user-123"
# print(a.isidentifier())
# a = "Homer"
# print(a.isidentifier())
# a = "for"
# print(a.isidentifier())

# 17.islower()
# Возвращает True, если все символы строки являются строчными (т. е., стоят в нижнем регистре), а в строке
# есть как минимум один символ. В противном случае возвращает False.
# Речь идет о символах, которые в принципе могут быть как в нижнем, так и в верхнем регистре, т. е., относящихся
# к одной из общих категорий «Lu», «Ll» или «Lt».
# Чтобы перевести строку в нижний регистр, можно использовать метод casefold() (это показано в последнем примере).
# a = " "
# print(a.islower())
# a = "123"
# print(a.islower())
# a = "_user_123"
# print(a.islower())
# a = "Homer"
# print(a.islower())
# a = "HOMER"
# print(a.islower())
# a = "homer"
# print(a.islower())
# a = "HOMER"
# a = a.casefold() #Force lowercase
# print(a.islower())

# 18.isnumeric()
# Возвращает True, если все символы в строке являются числовыми, и в строке есть хотя бы один символ. Иначе
# возвращает False.
# К числовым символам относятся все цифры, а также все символы, имеющие в Unicode значение свойства
# Numeric_Type=Digit, Numeric_Type=Decimal или Numeric_Type=Numeric.
# c = "123"
# print(c.isnumeric())
# c = u"\u00B2"
# print(c.isnumeric())
# c = "1.23"
# print(c.isnumeric())
# c = "u123"
# print(c.isnumeric())
# c = "Fitness"
# print(c.isnumeric())
# c = "$*%!!!"
# print(c.isnumeric())

# 19.isprintable()
# Возвращает True, если все символы в строке являются печатаемыми (и при этом в строке есть хотя бы один символ).
# Иначе возвращает False.
# К непечатаемым символам относятся символы, определенные в базе данных Unicode как «Other» или «Separator»,
# за исключением пробела ASCII (0x20), который считается печатаемым.
# В этом контексте к печатаемым символам относятся те, которые не должны экранироваться при вызове
# метода repr() для этой строки. Это не касается обработки строк, записанных в sys.stdout или sys.stderr.
# a = ""
# print(a.isprintable())
# a = " "
# print(a.isprintable())
# a = u"\u00B2"
# print(a.isprintable())
# a = "Bart"
# print(a.isprintable())
# a = "\t"
# print(a.isprintable())
# a = "\r\n"
# print(a.isprintable())
# a = "Bart \r"
# print(a.isprintable())

# 20.isspace()
# Возвращает True, если строка состоит из одних пробелов (и строка при этом не пустая). В противном случае возвращает
# False.
# К символам пробелов относятся те, который в базе данных Unicode определены как «Other» или «Separator» и
# имеют двунаправленное свойство «WS», «B» или «S».
# a = ""
# print(a.isspace())
# a = " "
# print(a.isspace())
# a = "Bart"
# print(a.isspace())
# a = "\t"
# print(a.isspace())
# a = "\r\n"
# print(a.isspace())
# a = "Bart \r"
# print(a.isspace())

# 21.istitle()
# Возвращает True, если строка написана в title case (т. е., каждое слово написано с заглавной буквы, а все
# остальные буквы в словах строчные; это один из возможных вариантов набор заголовков, отсюда название).
# Чтобы метод вернул True, строка также не должна быть пустой. В противном случае возвращается False.
# a = ""
# print(a.istitle())
# a = " "
# print(a.istitle())
# a = " t"
# print(a.istitle())
# a = " T"
# print(a.istitle())
# a = "Tea"
# print(a.istitle())
# a = "Tea and Coffee"
# print(a.istitle())
# a = "Tea And Coffee"
# print(a.istitle())
# a = "1. Tea & Coffee \r"
# print(a.istitle())

# 22.isupper()
# Этот метод возвращает True, если все символы в строке стоят в верхнем регистре (т. е., заглавные), при этом строка
# содержит хотя бы один символ. В противном случе возвращается False.
# Речь идет о символах, которые в принципе могут быть как в нижнем, так и в верхнем регистре, т. е., относящихся к
# одной из общих категорий «Lu», «Ll» или «Lt».
# a = " "
# print(a.isupper())
# a = "123"
# print(a.isupper())
# a = "_USER_123"
# print(a.isupper())
# a = "Homer"
# print(a.isupper())
# a = "HOMER"
# print(a.isupper())
# a = "homer"
# print(a.isupper())
# a = "HOMER"
# a = a.casefold() #Force lowercase
# print(a.isupper())

# 23.join(iterable)
# Возвращает строку, которая является конкатенацией строк в итерируемом объекте.
# Если в итерируемом объекте будут любые нестроковые значения, включая байтовые объекты, вы получите TypeError.
# Разделителем между элементами служит заданная строка.
# a = "-"
# print(a.join("123"))
# a = "."
# print(a.join("USA"))
# a = ". "
# print(a.join(("Dr", "Who")))

# 24.ljust(width[, fillchar])
# Возвращает строку, выровненную по левому краю в рамках большей строки (ее ширина в символах задается при
# помощи параметра width).
# Для заполнения места, не занятого оригинальной строкой, используются ASCII пробелы, но можно и указать желаемый
# символ — при помощи параметра fillchar.
# Если заданная ширина строки меньше или равна длине оригинальной строки
# (определяется при помощи len(s)), то возвращается оригинальная строка.
# Здесь все по аналогии с методом center(), только там строка выравнивается по центру.
# a = "bee"
# b = a.ljust(12, "-")
# print(b)

# 25.lower()
# Возвращает копию строки, в которой все символы переведены в нижний регистр.
# Разумеется, речь идет о символах, которые в принципе могут быть как в верхнем, так и в нижнем регистре.
# В плане замены символов этот метод менее агрессивен, чем casefold(). Для иллюстрации различия часто приводится
# пример с немецкой буквой ß, которая эквивалентна ss. Поскольку эта буква уже стоит в нижнем регистре, метод lower()
# ее просто пропустит, а вот метод casefold() преобразует в ss.
# a = "BEE"
# print(a.lower())

# 26.lstrip([chars])
# Возвращает копию строки с удаленными первыми символами (т.е., символами, стоящими слева).
# В аргументе chars задается набор символов, которые нужно удалить. Если не задавать этот аргумент или установить
# его в None, по умолчанию будут удалены все пробелы слева.
# Обратите внимание, что в качестве аргумента задается не префикс, а именно набор символов, т. е., их порядок не
# имеет значения. Метод будет удалять все символы из набора, двигаясь слева направо, пока не достигнет первого символа,
# не входящего в набор.
# a = "      Bee      "
# print(a.lstrip(), "!")
# a = "-----Bee-----"
# print(a.lstrip("-"))

# 27.maketrans(x[, y[, z]])
# Это статический метод, возвращающий таблицу преобразования символов, которую затем можно применить для метода
# translate().
# Если передается только один аргумент, он должен быть словарем, в котором целые числа или символы (строки с длиной,
# равной 1) Unicode отражены на целые числа Unicode или строки
# (любой длины) или установлены на None. В таком случае ключи символов будут преобразованы в числа.
# Если передается два аргумента, это должны быть строки одинаковой длины. В результате получится словарь, в котором
# каждый символ строки x будет отражен на символ в строке y, стоящий на такой же позиции.
# Если задается третий аргумент, это должна быть строка, символы которой в результате будут отражены в None.
# frm = "SecrtCod"
# to = "12345678"
# trans_table = str.maketrans(frm, to)
# secret_code = "Secret Code".translate(trans_table)
# print(secret_code)

# 28.partition(sep)
# Разделяет строку в месте первого вхождения заданного разделителя (sep) и возвращает кортеж из трех элементов:
# части строки до разделителя, самого разделителя и части строки после него.
# Если заданный разделитель не найден, метод опять же возвращает кортеж из трех элементов, где первым элементом будет
# вся неразделенная строка, за которой будут идти две пустые строки.
# a = "Python-program"
# print(a.partition("-"))
# print(a.partition("."))

# 29.replace(old, new[, count])	Возвращает копию строки, где все вхождения old заменены на new.
# Если добавлен опциональный аргумент count, будут заменены не все вхождения old, а столько, сколько указано в count.
# То есть, если count это 3, то будут заменены только первые 3 вхождения old.
# a = "Tea bag. Tea cup. Tea leaves."
# print(a.replace("Tea", "Coffee"))
# print(a.replace("Tea", "Coffee", 2))

# 30.rfind(sub[, start[, end]])
# Возвращает самый большой индекс в строке, на котором была найдена указанная подстрока.
# При помощи опциональных аргументов start и end можно задать диапазон для поиска подстроки в строке
# (эти аргументы интерпретируются как срез). Если подстрока в строке не найдена, возвращается -1.
# Работа этого метода аналогична работе метода find(), только find() ищет индекс первого вхождения подстроки.
# a = "Yes Fitness"
# print(a.rfind("Y"))
# print(a.rfind("e"))
# print(a.rfind("s"))
# print(a.rfind("ss"))
# print(a.rfind("y"))
# print(a.rfind("z"))
# print(a.rfind("Homer"))

# 31.rindex(sub[, start[, end]])
# Этот метод похож на приведенный выше метод rfind(), но если он не находит заданную подстроку sub, то
# выдает ValueError, а не -1.
# В общем, как rfind() можно считать зеркальным отражением find(), так и rindex(), по сути, отражение index().
# a = "Yes Fitness"
# print(a.rindex("Y"))
# print(a.rindex("e"))
# print(a.rindex("s"))
# print(a.rindex("ss"))
# print(a.rindex("y"))
# print(a.rindex("z"))
# print(a.rindex("Homer"))

# 32.rjust(width[, fillchar])
# Возвращает строку, выровненную по правому краю в рамках большей строки (ее ширина в символах задается при помощи
# параметра width).
# Для заполнения места, не занятого оригинальной строкой, используются символы, заданные при помощи параметра fillchar.
# Если символ-заполнитель не задан, по умолчанию будут использоваться ASCII пробелы.
# В случае, если заданная ширина строки меньше или равна длине оригинальной строки (определяется при помощи len(s)),
# возвращается оригинальная строка.
# Здесь все по аналогии с методом center(), где строка выравнивается по центру, и с методом ljust(),
# где строка выравнивается по левому краю.
# a = "bee"
# b = a.rjust(12, "-")
# print(b)

# 33.rpartition(sep)
# Разделяет строку в месте последнего вхождения заданного разделителя (sep) и
# возвращает кортеж из трех элементов: части строки до разделителя, самого разделителя и части строки после него.
# Если заданный разделитель не найден, метод опять же возвращает кортеж из трех элементов,
# где двумя первыми элементами будут пустые строки, а последним — неразделенная исходная строка.
# Работа этого метода как бы зеркально отражает работу метода partition().
# a = "Homer-Jay-Simpson"
# print(a.rpartition("-"))
# print(a.rpartition("."))

# 34.rsplit(sep=None, maxsplit=-1)
# Возвращает список слов в строке, используя sep в качестве разделителя.
# Если задан параметр maxsplit, будет отделено указанное число слов, причем с правого края строки.
# Разделитель можно не задавать или указать None — в таком случае разделителем будет считаться любой пробел
# (или подстрока из пробелов).
# Работа rsplit() — зеркальное отражение работы метода split(), о котором еще будет идти речь ниже.
# a = "Homer Jay Simpson"
# print(a.rsplit())
# a = "Homer-Jay-Simpson"
# print(a.rsplit(sep="-",maxsplit=1))

# 35.rstrip([chars])
# Возвращает копию строки с удаленными последними символами (т.е., символами, стоящими справа).
# В аргументе chars задается набор символов, которые нужно удалить. Если не задавать этот аргумент или
# установить его в None, по умолчанию будут удалены все пробелы справа.
# Обратите внимание, что в качестве аргумента задается не суффикс, а именно набор символов,
# т. е., их порядок не имеет значения. Метод будет удалять все символы из набора, двигаясь справа налево,
# пока не достигнет первого символа, не входящего в набор.
# Работа этого метода — зеркальное отражение работы lstrip().
# a = "      Bee      "
# print(a.rstrip(), "!")
# a = "-----Bee-----"
# print(a.rstrip("-"))

# 36.split(sep=None, maxsplit=-1)
# Этот метод разбивает заданную строку на отдельные слова и возвращает список этих слов.
# Строка-разделитель задается при помощи параметра sep.
# Если разделитель указан, то последовательно расположенные разделители не группируются вместе.
# В этом случае считается, что они разделяют пустые строки. Например, '1,,2'.split(',') вернет ['1', '', '2'].
# Заданный разделитель может состоять из нескольких символов. Например, '1<>2<>3'.split('<>') вернет ['1', '2', '3'].
# Если метод split() применить к пустой строке и при этом указать разделитель, метод вернет [''].
# Если разделитель не задан или задан None, применяется особый алгоритм разбиения. Последовательно расположенные
# пробелы трактуются как один разделитель. Вследствие этого, если строка начинается с ряда пробелов или заканчивается
# ими,
# в итоговый список не попадут пустые строки.
# Если исходная строка состоит исключительно из пробелов или пуста, а в качестве разделителя будет указан None,
# то метод вернет [].
# a = "Homer Jay Simpson"
# print(a.split())
# a = "Homer-Jay-Simpson"
# print(a.split(sep="-",maxsplit=1))
# a = "Homer,,Bart,"
# print(a.split(","))
# a = "Homer,,Bart"
# print(a.split(",", maxsplit=1))
# a = "Homer<>Bart<>Marge"
# print(a.split("<>"))

# 37.splitlines([keepends])
# Если у вас есть многострочная строка, где строчки разделены, например, символами переноса
# строки, этот метод может вернуть список строчек, из которых состоит ваша строка.
# Сами символы, отделяющие строчки, не будут входить в итоговый список, если не указать keepends=True.
# Этот метод делит строку по следующим экранированным последовательностям:
# \n — перевод строки;
# \r — возврат каретки;
# \r\n — возврат каретки + перевод строки;
# \v или \x0b — вертикальная табуляция;
# \f или \x0c — разрыв страницы;
# \x1c — разделитель файлов;
# \x1d — разделитель групп;
# \x1e — разделитель записей;
# \x85 — следующая строка;
# \u2028 — разделитель строк;
# \u2029 — разделитель абзацев.
# a = "Tea\n\nand coffee\rcups\r\n"
# print(a.splitlines())
# print(a.splitlines(keepends=True))

# 38.startswith(prefix[, start[, end]])
# Возвращает True, если строка начинается с указанного префикса; в противном случае возвращает False.
# Префикс также может быть кортежем префиксов.
# Если указывается аргумент start, проверка начинается с указанной позиции. При указании
# аргумента end проверка останавливается на указанном символе. Оба аргумента опциональны.
# Этот метод — зеркальное отражение метода endswith(), о котором мы уже говорили.
# a = "Homer"
# print(a.startswith("H"))
# print(a.startswith("h"))
# print(a.startswith("Homer"))
# print(a.startswith("z"))
# print(a.startswith("om", 1, 3))

# 39.strip([chars])
# Возвращает копию строки, в начале и конце которой удалены заданные символы. Этот набор символов, подлежащих удалению,
# задается в аргументе chars. Если не задавать этот аргумент или установить его в None, по умолчанию будут удалены все
# пробелы слева и справа.
# Обратите внимание, что в качестве аргумента задается не префикс или суффикс, а именно набор символов,
# т. е., их порядок не имеет значения. Метод будет удалять все символы из набора, двигаясь и слева направо,
# и справа налево, пока с каждой стороны не достигнет первого символа, не входящего в набор.
# Работа этого метода — своего рода комбинация работы методов lstrip() и rstrip().
# a = "      Bee      "
# print(a.strip(), "!")
# a = "-----Bee-----"
# print(a.strip("-"))

# 40.swapcase()
# Возвращает копию строки, в которой все символы, стоящие в верхнем регистре, переведены в нижний, и наоборот.
# Обратите внимание, что повторное применение метода swapcase() не всегда вернет строку в первоначальном виде.
# Есть такие комбинации, когда двум разным символам в нижнем регистре соответствует один символ в верхнем,
# так что «переключение» регистра может дать неожиданный эффект. Примеры можно посмотреть в обсуждении на
# Stack Overflow.
# a = "Homer Simpson"
# print(a.swapcase())

# 41.title()
# Возвращает копию строки в формате заголовка (когда каждое слово в строке начинается с
# заглавной буквы, а все остальные — строчные).
# Совет: если хотите сделать заглавной только первую букву строки, используйте метод capitalize().
# a = "tea and coffee"
# print(a.title())
# a = "TEA AND COFFEE"
# print(a.title())

# 42.translate(table)
# Возвращает переведенную копию строки, в которой каждый символ преобразован по правилам, прописанным в таблице
# перевода.
# Для создания таблицы перевода можно воспользоваться вспомогательной функцией maketrans().
# frm = "SecrtCod"
# to = "12345678"
# trans_table = str.maketrans(frm, to)
# secret_code = "Secret Code".translate(trans_table)
# print(secret_code)

# 43.upper()	Возвращает копию строки, в которой все символы переведены в верхний регистр.
# Речь идет о символах, которые в принципе могут быть как в верхнем, так и в нижнем регистре.
# a = "bee"
# print(a.upper())

# 44.zfill(width)
# Возвращает копию строки, которая приведена к указанной длине (задается при помощи параметра width).
# Если исходная строка короче указанной длины, «пустота» заполняется нулями ASCII слева.
# Знаки +/- указываются в исходной строке и учитываются при подсчете ее длины.
# Если длина исходной строки больше или равна width, будет возвращена просто исходная строка.
# a = "36"
# print(a.zfill(5))
# a = "-36"
# print(a.zfill(5))
# a = "+36"
# print(a.zfill(5))